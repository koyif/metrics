package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type StructInfo struct {
	Name    string
	Fields  []*ast.Field
	PkgName string
	PkgPath string
}

func main() {
	rootDir, err := os.Getwd()
	if err != nil {
		log.Printf("Error getting working directory: %v\n", err)
		os.Exit(1)
	}

	pkgStructs, err := scanPackages(rootDir)
	if err != nil {
		log.Printf("Error scanning packages: %v\n", err)
		os.Exit(1)
	}

	for pkgPath, structs := range pkgStructs {
		if len(structs) == 0 {
			continue
		}

		err := generateResetFile(pkgPath, structs)
		if err != nil {
			log.Printf("Error generating reset file for %s: %v\n", pkgPath, err)
			os.Exit(1)
		}

		log.Printf("Generated reset.gen.go for package %s with %d struct(s)\n", pkgPath, len(structs))
	}
}

func scanPackages(rootDir string) (map[string][]StructInfo, error) {
	pkgStructs := make(map[string][]StructInfo)

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("error walking %s: %w", path, err)
		}

		if info.IsDir() {
			name := info.Name()
			if name == "vendor" || name == ".git" || strings.HasPrefix(name, ".") {
				return filepath.SkipDir
			}
			return nil
		}

		if !strings.HasSuffix(path, ".go") ||
			strings.HasSuffix(path, "_test.go") ||
			strings.HasSuffix(path, ".gen.go") {
			return nil
		}

		structs, err := parseFile(path)
		if err != nil {
			return fmt.Errorf("error parsing %s: %w", path, err)
		}

		if len(structs) > 0 {
			pkgDir := filepath.Dir(path)
			pkgStructs[pkgDir] = append(pkgStructs[pkgDir], structs...)
		}

		return nil
	})

	return pkgStructs, err
}

func parseFile(filename string) ([]StructInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("error parsing file %s: %w", filename, err)
	}

	var structs []StructInfo

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		if !hasGenerateResetComment(genDecl.Doc) {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structs = append(structs, StructInfo{
				Name:    typeSpec.Name.Name,
				Fields:  structType.Fields.List,
				PkgName: node.Name.Name,
				PkgPath: filepath.Dir(filename),
			})
		}
	}

	return structs, nil
}

func hasGenerateResetComment(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}

	for _, comment := range doc.List {
		text := strings.TrimSpace(strings.TrimPrefix(comment.Text, "//"))
		if strings.HasPrefix(text, "generate:reset") {
			return true
		}
	}
	return false
}

func generateResetFile(pkgPath string, structs []StructInfo) error {
	if len(structs) == 0 {
		return nil
	}

	var buf bytes.Buffer

	buf.WriteString("// Code generated by cmd/reset. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", structs[0].PkgName))

	for _, s := range structs {
		buf.WriteString(generateResetMethod(s))
		buf.WriteString("\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("error formatting generated code: %w", err)
	}

	outputPath := filepath.Join(pkgPath, "reset.gen.go")
	err = os.WriteFile(outputPath, formatted, 0644)
	if err != nil {
		return fmt.Errorf("error writing file %s: %w", outputPath, err)
	}

	return nil
}

func generateResetMethod(s StructInfo) string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("func (r *%s) Reset() {\n", s.Name))
	buf.WriteString("\tif r == nil {\n")
	buf.WriteString("\t\treturn\n")
	buf.WriteString("\t}\n\n")

	for _, field := range s.Fields {
		if len(field.Names) == 0 {
			continue
		}

		for _, name := range field.Names {
			fieldName := name.Name
			resetCode := generateFieldReset(fieldName, field.Type, "\t")
			if resetCode != "" {
				buf.WriteString(resetCode)
			}
		}
	}

	buf.WriteString("}\n")
	return buf.String()
}

func generateFieldReset(fieldName string, fieldType ast.Expr, indent string) string {
	switch t := fieldType.(type) {
	case *ast.Ident:
		return generatePrimitiveReset(fieldName, t.Name, indent)

	case *ast.StarExpr:
		return generatePointerReset(fieldName, t.X, indent)

	case *ast.ArrayType:
		if t.Len == nil {
			return fmt.Sprintf("%sr.%s = r.%s[:0]\n", indent, fieldName, fieldName)
		}
		return generateArrayReset(fieldName, t, indent)

	case *ast.MapType:
		return fmt.Sprintf("%sclear(r.%s)\n", indent, fieldName)

	case *ast.StructType:
		return generateStructReset(fieldName, indent)

	case *ast.SelectorExpr:
		return generateSelectorReset(fieldName, t, indent)

	default:
		return ""
	}
}

func generatePrimitiveReset(fieldName, typeName, indent string) string {
	switch typeName {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"byte", "rune":
		return fmt.Sprintf("%sr.%s = 0\n", indent, fieldName)
	case "float32", "float64":
		return fmt.Sprintf("%sr.%s = 0\n", indent, fieldName)
	case "string":
		return fmt.Sprintf("%sr.%s = \"\"\n", indent, fieldName)
	case "bool":
		return fmt.Sprintf("%sr.%s = false\n", indent, fieldName)
	default:
		return generateStructReset(fieldName, indent)
	}
}

func generatePointerReset(fieldName string, baseType ast.Expr, indent string) string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("%sif r.%s != nil {\n", indent, fieldName))

	switch t := baseType.(type) {
	case *ast.Ident:
		switch t.Name {
		case "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"byte", "rune":
			buf.WriteString(fmt.Sprintf("%s\t*r.%s = 0\n", indent, fieldName))
		case "float32", "float64":
			buf.WriteString(fmt.Sprintf("%s\t*r.%s = 0\n", indent, fieldName))
		case "string":
			buf.WriteString(fmt.Sprintf("%s\t*r.%s = \"\"\n", indent, fieldName))
		case "bool":
			buf.WriteString(fmt.Sprintf("%s\t*r.%s = false\n", indent, fieldName))
		default:
			buf.WriteString(fmt.Sprintf("%s\tif resetter, ok := interface{}(r.%s).(interface{ Reset() }); ok {\n", indent, fieldName))
			buf.WriteString(fmt.Sprintf("%s\t\tresetter.Reset()\n", indent))
			buf.WriteString(fmt.Sprintf("%s\t}\n", indent))
		}

	case *ast.StructType, *ast.MapType, *ast.ArrayType:
		buf.WriteString(fmt.Sprintf("%s\tif resetter, ok := interface{}(r.%s).(interface{ Reset() }); ok {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s\t\tresetter.Reset()\n", indent))
		buf.WriteString(fmt.Sprintf("%s\t}\n", indent))

	case *ast.SelectorExpr:
		buf.WriteString(fmt.Sprintf("%s\tif resetter, ok := interface{}(r.%s).(interface{ Reset() }); ok {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s\t\tresetter.Reset()\n", indent))
		buf.WriteString(fmt.Sprintf("%s\t}\n", indent))
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))
	return buf.String()
}

func generateStructReset(fieldName, indent string) string {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("%sif resetter, ok := interface{}(&r.%s).(interface{ Reset() }); ok {\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%s\tresetter.Reset()\n", indent))
	buf.WriteString(fmt.Sprintf("%s}\n", indent))
	return buf.String()
}

func generateArrayReset(fieldName string, arrType *ast.ArrayType, indent string) string {
	return ""
}

func generateSelectorReset(fieldName string, sel *ast.SelectorExpr, indent string) string {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("%sif resetter, ok := interface{}(&r.%s).(interface{ Reset() }); ok {\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%s\tresetter.Reset()\n", indent))
	buf.WriteString(fmt.Sprintf("%s}\n", indent))
	return buf.String()
}
